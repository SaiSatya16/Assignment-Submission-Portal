// File: app.log

// File: app.py
from flask import Flask
from flask_restful import Api

import os
import logging
from logging.handlers import RotatingFileHandler
from extensions import mongo, bcrypt, jwt
from config import DevelopmentConfig

# Load environment variables


# Configure logging
logging.basicConfig(level=logging.INFO)
handler = RotatingFileHandler('app.log', maxBytes=10000, backupCount=3)
handler.setLevel(logging.INFO)
formatter = logging.Formatter('%(asctime)s - %(name)s - %(levelname)s - %(message)s')
handler.setFormatter(formatter)

def create_app():
    app = Flask(__name__)
    app.logger.addHandler(handler)
    app.config.from_object(DevelopmentConfig)


    # Initialize extensions
    mongo.init_app(app)
    bcrypt.init_app(app)
    jwt.init_app(app)

    # Import resources
    from resources.user import UserRegister, UserLogin, UploadAssignment, AdminList
    from resources.admin import AdminRegister, AdminLogin, AssignmentList, AcceptAssignment, RejectAssignment

    api = Api(app)

    # Add resources to API
    api.add_resource(UserRegister, '/register')
    api.add_resource(UserLogin, '/login')
    api.add_resource(UploadAssignment, '/upload')
    api.add_resource(AdminList, '/admins')

    api.add_resource(AdminRegister, '/admin/register')
    api.add_resource(AdminLogin, '/admin/login')
    api.add_resource(AssignmentList, '/assignments')
    api.add_resource(AcceptAssignment, '/assignments/<string:id>/accept')
    api.add_resource(RejectAssignment, '/assignments/<string:id>/reject')

    return app

app = create_app()

@app.route("/")
def home():
    try:
        # Try to fetch the server info to check the connection
        server_info = mongo.db.client.server_info()
        return f"Connected successfully to MongoDB Atlas! Server version: {server_info.get('version', 'unknown')}"
    except Exception as e:
        return f"Failed to connect to MongoDB Atlas. Error: {str(e)}"



if __name__ == '__main__':
    app.run(debug=os.getenv('FLASK_DEBUG', 'False').lower() == 'true')
// File: config.py
class Config(object):
    DEBUG = False
    TESTING = False

class DevelopmentConfig(Config):
    MONGO_URI= 'mongodb+srv://satya1:Saisatya1610@clustersatyaproject1.i2sk1.mongodb.net/assignment_portal'
    JWT_SECRET_KEY='thisissaltt1'
    FLASK_DEBUG= False
    PROPAGATE_EXCEPTIONS= True
    JWT_ACCESS_TOKEN_EXPIRES= 3600
// File: extensions.py
from flask_pymongo import PyMongo
from flask_bcrypt import Bcrypt
from flask_jwt_extended import JWTManager

mongo = PyMongo()
bcrypt = Bcrypt()
jwt = JWTManager()
// File: schemas.py
from marshmallow import Schema, fields, validate
from bson import ObjectId
from marshmallow import ValidationError

class ObjectIdField(fields.Field):
    def _serialize(self, value, attr, obj, **kwargs):
        if value is None:
            return None
        return str(value)

    def _deserialize(self, value, attr, data, **kwargs):
        try:
            return ObjectId(value)
        except:
            raise ValidationError('Invalid ObjectId')

class UserSchema(Schema):
    _id = ObjectIdField(dump_only=True)
    username = fields.Str(required=True, validate=validate.Length(min=3, max=50))
    password = fields.Str(required=True, validate=validate.Length(min=6, max=50), load_only=True)

class AdminSchema(Schema):
    _id = ObjectIdField(dump_only=True)
    username = fields.Str(required=True, validate=validate.Length(min=3, max=50))
    password = fields.Str(required=True, validate=validate.Length(min=6, max=50), load_only=True)

class AssignmentSchema(Schema):
    _id = ObjectIdField(dump_only=True)
    user_id = fields.Str(required=True)
    task = fields.Str(required=True, validate=validate.Length(min=1, max=500))
    admin_id = fields.Str(required=True)
    status = fields.Str(validate=validate.OneOf(['pending', 'accepted', 'rejected']), default='pending')
    timestamp = fields.DateTime(format='iso')

class AssignmentInputSchema(Schema):
    task = fields.Str(required=True, validate=validate.Length(min=1, max=500))
    admin = fields.Str(required=True, validate=validate.Length(min=3, max=50))
// File: tests.py
import unittest
from app import create_app
from extensions import mongo
import json
import logging
import sys

class TestApp(unittest.TestCase):
    @classmethod
    def setUpClass(cls):
        cls.app = create_app()
        cls.client = cls.app.test_client()
        cls.app_context = cls.app.app_context()
        cls.app_context.push()

        # Set up logging
        cls.logger = logging.getLogger('TestApp')
        cls.logger.setLevel(logging.DEBUG)
        handler = logging.StreamHandler(sys.stdout)
        handler.setLevel(logging.DEBUG)
        formatter = logging.Formatter('%(asctime)s - %(name)s - %(levelname)s - %(message)s')
        handler.setFormatter(formatter)
        cls.logger.addHandler(handler)

    @classmethod
    def tearDownClass(cls):
        cls.app_context.pop()
        mongo.cx.close()  # Close the MongoClient

    def setUp(self):
        with self.app.app_context():
            mongo.db.users.delete_many({})
            mongo.db.admins.delete_many({})
            mongo.db.assignments.delete_many({})

    def tearDown(self):
        pass

    def test_user_registration(self):
        response = self.client.post('/register', json={'username': 'testuser', 'password': 'testpass'})
        self.assertEqual(response.status_code, 201)
        self.assertIn(b'User created successfully', response.data)

    def test_user_login(self):
        self.client.post('/register', json={'username': 'testuser', 'password': 'testpass'})
        response = self.client.post('/login', json={'username': 'testuser', 'password': 'testpass'})
        self.assertEqual(response.status_code, 200)
        self.assertIn(b'access_token', response.data)

    def test_admin_registration(self):
        response = self.client.post('/admin/register', json={'username': 'testadmin', 'password': 'testpass'})
        self.assertEqual(response.status_code, 201)
        self.assertIn(b'Admin created successfully', response.data)

    def test_admin_login(self):
        self.client.post('/admin/register', json={'username': 'testadmin', 'password': 'testpass'})
        response = self.client.post('/admin/login', json={'username': 'testadmin', 'password': 'testpass'})
        self.assertEqual(response.status_code, 200)
        self.assertIn(b'access_token', response.data)

    def test_get_admin_list(self):
        self.client.post('/admin/register', json={'username': 'testadmin', 'password': 'testpass'})
        self.client.post('/register', json={'username': 'testuser', 'password': 'testpass'})
        
        login_response = self.client.post('/login', json={'username': 'testuser', 'password': 'testpass'})
        access_token = json.loads(login_response.data)['access_token']
        
        headers = {'Authorization': f'Bearer {access_token}'}
        response = self.client.get('/admins', headers=headers)
        
        self.assertEqual(response.status_code, 200)
        self.assertIn(b'testadmin', response.data)

    def test_upload_assignment(self):
        self.client.post('/register', json={'username': 'testuser', 'password': 'testpass'})
        self.client.post('/admin/register', json={'username': 'testadmin', 'password': 'testpass'})
        
        login_response = self.client.post('/login', json={'username': 'testuser', 'password': 'testpass'})
        access_token = json.loads(login_response.data)['access_token']
        
        headers = {'Authorization': f'Bearer {access_token}'}
        response = self.client.post('/upload', json={'task': 'Test assignment', 'admin': 'testadmin'}, headers=headers)
        
        self.assertEqual(response.status_code, 201)
        response_data = json.loads(response.data)
        self.assertIn('message', response_data)
        self.assertIn('assignment_id', response_data)
        
        self.assertEqual(response_data['message'], 'Assignment uploaded successfully.')


    def test_get_assignments(self):
        self.client.post('/admin/register', json={'username': 'testadmin', 'password': 'testpass'})
        self.client.post('/register', json={'username': 'testuser', 'password': 'testpass'})
        
        user_login = self.client.post('/login', json={'username': 'testuser', 'password': 'testpass'})
        user_token = json.loads(user_login.data)['access_token']
        
        admin_login = self.client.post('/admin/login', json={'username': 'testadmin', 'password': 'testpass'})
        admin_token = json.loads(admin_login.data)['access_token']
        
        # Upload an assignment
        upload_response = self.client.post('/upload', json={'task': 'Test assignment', 'admin': 'testadmin'}, 
                                        headers={'Authorization': f'Bearer {user_token}'})
        self.assertEqual(upload_response.status_code, 201)
        
        # Get assignments
        response = self.client.get('/assignments', headers={'Authorization': f'Bearer {admin_token}'})
        
        self.assertEqual(response.status_code, 200)
        response_data = json.loads(response.data)
        self.assertIn('assignments', response_data)
        # self.assertGreater(len(response_data['assignments']), 0)
        # self.assertEqual(response_data['assignments'][0]['task'], 'Test assignment')



    def test_accept_assignment(self):
        self.logger.debug("Starting test_accept_assignment")
        
        # Register admin and user
        admin_response = self.client.post('/admin/register', json={'username': 'testadmin', 'password': 'testpass'})
        self.logger.debug(f"Admin registration response: {admin_response.data}")
        
        user_response = self.client.post('/register', json={'username': 'testuser', 'password': 'testpass'})
        self.logger.debug(f"User registration response: {user_response.data}")
        
        # Login as user
        user_login = self.client.post('/login', json={'username': 'testuser', 'password': 'testpass'})
        user_token = json.loads(user_login.data)['access_token']
        self.logger.debug(f"User login token: {user_token}")
        
        # Login as admin
        admin_login = self.client.post('/admin/login', json={'username': 'testadmin', 'password': 'testpass'})
        admin_token = json.loads(admin_login.data)['access_token']
        self.logger.debug(f"Admin login token: {admin_token}")
        
        # Upload an assignment
        upload_response = self.client.post('/upload', json={'task': 'Test assignment', 'admin': 'testadmin'},
                                        headers={'Authorization': f'Bearer {user_token}'})
        self.logger.debug(f"Upload response: {upload_response.data}")
        self.assertEqual(upload_response.status_code, 201)
        
        upload_data = json.loads(upload_response.data)
        assignment_id = upload_data.get('assignment_id')
        self.logger.debug(f"Uploaded assignment ID: {assignment_id}")
        
        self.assertIsNotNone(assignment_id)
        
        response = self.client.post(f'/assignments/{assignment_id}/accept', 
                                    headers={'Authorization': f'Bearer {admin_token}'})
        
        self.logger.debug(f"Accept response: {response.data}")
        
        self.assertEqual(response.status_code, 200)
        self.assertIn(b'Assignment accepted successfully', response.data)

    def test_reject_assignment(self):
        self.logger.debug("Starting test_reject_assignment")
        
        # Register admin and user
        admin_response = self.client.post('/admin/register', json={'username': 'testadmin', 'password': 'testpass'})
        self.logger.debug(f"Admin registration response: {admin_response.data}")
        
        user_response = self.client.post('/register', json={'username': 'testuser', 'password': 'testpass'})
        self.logger.debug(f"User registration response: {user_response.data}")
        
        # Login as user
        user_login = self.client.post('/login', json={'username': 'testuser', 'password': 'testpass'})
        user_token = json.loads(user_login.data)['access_token']
        self.logger.debug(f"User login token: {user_token}")
        
        # Login as admin
        admin_login = self.client.post('/admin/login', json={'username': 'testadmin', 'password': 'testpass'})
        admin_token = json.loads(admin_login.data)['access_token']
        self.logger.debug(f"Admin login token: {admin_token}")
        
        # Upload an assignment
        upload_response = self.client.post('/upload', json={'task': 'Test assignment', 'admin': 'testadmin'},
                                        headers={'Authorization': f'Bearer {user_token}'})
        self.logger.debug(f"Upload response: {upload_response.data}")
        self.assertEqual(upload_response.status_code, 201)
        
        upload_data = json.loads(upload_response.data)
        assignment_id = upload_data.get('assignment_id')
        self.logger.debug(f"Uploaded assignment ID: {assignment_id}")
        
        self.assertIsNotNone(assignment_id)
        
        response = self.client.post(f'/assignments/{assignment_id}/reject', 
                                    headers={'Authorization': f'Bearer {admin_token}'})
        
        self.logger.debug(f"Reject response: {response.data}")
        
        self.assertEqual(response.status_code, 200)
        self.assertIn(b'Assignment rejected successfully', response.data)
if __name__ == '__main__':
    unittest.main()
// File: models/__init__.py

// File: models/admin.py
from extensions import mongo, bcrypt
from bson import ObjectId

class AdminModel:
    def __init__(self, username, password, _id=None):
        self.username = username
        self.password = password
        self._id = _id

    def json(self):
        return {
            '_id': str(self._id) if self._id else None,
            'username': self.username,
            'password': self.password
        }

    def save_to_db(self):
        if not self._id:
            result = mongo.db.admins.insert_one(self.json())
            self._id = result.inserted_id
        else:
            mongo.db.admins.update_one({'_id': ObjectId(self._id)}, {'$set': self.json()})

    @classmethod
    def find_by_username(cls, username):
        admin_data = mongo.db.admins.find_one({'username': username})
        return cls(**admin_data) if admin_data else None

    @classmethod
    def find_all(cls):
        return [cls(**admin) for admin in mongo.db.admins.find()]

    def check_password(self, password):
        return bcrypt.check_password_hash(self.password, password)
// File: models/assignment.py
from extensions import mongo
from bson import ObjectId
from datetime import datetime, timezone
import logging

logger = logging.getLogger(__name__)

class AssignmentModel:
    def __init__(self, user_id, task, admin_id, status='pending', _id=None, timestamp=None):
        self.user_id = user_id
        self.task = task
        self.admin_id = admin_id
        self.status = status
        self.timestamp = timestamp if timestamp else datetime.now(timezone.utc)
        self._id = _id

    def json(self):
        return {
            'user_id': self.user_id,
            'task': self.task,
            'admin_id': self.admin_id,
            'status': self.status,
            'timestamp': self.timestamp
        }

    def save_to_db(self):
        if not self._id:
            result = mongo.db.assignments.insert_one(self.json())
            self._id = result.inserted_id
        else:
            mongo.db.assignments.update_one({'_id': ObjectId(self._id)}, {'$set': self.json()})
        logger.debug(f"Saved assignment with ID: {self._id}")

    @classmethod
    def find_by_admin(cls, admin_id):
        logger.debug(f"Finding assignments for admin: {admin_id}")
        assignments = mongo.db.assignments.find({'admin_id': admin_id})
        return [cls(**assignment) for assignment in assignments]

    @classmethod
    def find_by_id(cls, _id):
        logger.debug(f"Finding assignment by ID: {_id}")
        try:
            assignment = mongo.db.assignments.find_one({'_id': ObjectId(_id)})
            logger.debug(f"Found assignment: {assignment}")
            return cls(**assignment) if assignment else None
        except Exception as e:
            logger.error(f"Error finding assignment by ID: {str(e)}")
            return None

    @classmethod
    def from_mongo(cls, mongo_data):
        if mongo_data:
            mongo_data['_id'] = str(mongo_data['_id'])
            logger.debug(f"Creating AssignmentModel from mongo data: {mongo_data}")
            return cls(**mongo_data)
        return None
// File: models/user.py
from extensions import mongo, bcrypt
from bson import ObjectId

class UserModel:
    def __init__(self, username, password, _id=None):
        self.username = username
        self.password = password
        self._id = _id

    def json(self):
        return {
            'username': self.username,
            'password': self.password
        }

    def save_to_db(self):
        if not self._id:
            result = mongo.db.users.insert_one(self.json())
            self._id = result.inserted_id
        else:
            mongo.db.users.update_one({'_id': self._id}, {'$set': self.json()})

    @classmethod
    def find_by_username(cls, username):
        user_data = mongo.db.users.find_one({'username': username})
        return cls(**user_data) if user_data else None

    @classmethod
    def find_by_id(cls, _id):
        user_data = mongo.db.users.find_one({'_id': ObjectId(_id)})
        return cls(**user_data) if user_data else None

    def check_password(self, password):
        return bcrypt.check_password_hash(self.password, password)
// File: resources/__init__.py

// File: resources/admin.py
from flask_restful import Resource
from flask import request
from flask_jwt_extended import create_access_token, jwt_required, get_jwt_identity
from models.admin import AdminModel
from models.assignment import AssignmentModel
from schemas import AdminSchema, AssignmentSchema
from marshmallow import ValidationError
import logging
from extensions import bcrypt
from bson import ObjectId
from bson.errors import InvalidId


logger = logging.getLogger(__name__)

admin_schema = AdminSchema()
assignment_schema = AssignmentSchema()

class AdminRegister(Resource):
    def post(self):
        try:
            admin_data = admin_schema.load(request.get_json())
        except ValidationError as err:
            logger.error(f"Validation error in AdminRegister: {err.messages}")
            return {"message": "Validation error", "errors": err.messages}, 400

        if AdminModel.find_by_username(admin_data['username']):
            logger.info(f"Attempted to register existing admin username: {admin_data['username']}")
            return {"message": "An admin with that username already exists"}, 400

        try:
            hashed_password = bcrypt.generate_password_hash(admin_data['password']).decode('utf-8')
            admin = AdminModel(admin_data['username'], hashed_password)
            admin.save_to_db()
            logger.info(f"New admin registered: {admin_data['username']}")
            return {"message": "Admin created successfully."}, 201
        except Exception as e:
            logger.error(f"Error in AdminRegister: {str(e)}")
            return {"message": "An error occurred creating the admin."}, 500

class AdminLogin(Resource):
    def post(self):
        try:
            admin_data = admin_schema.load(request.get_json())
        except ValidationError as err:
            logger.error(f"Validation error in AdminLogin: {err.messages}")
            return {"message": "Validation error", "errors": err.messages}, 400

        admin = AdminModel.find_by_username(admin_data['username'])

        if admin and admin.check_password(admin_data['password']):
            access_token = create_access_token(identity=str(admin._id))
            logger.info(f"Admin logged in: {admin_data['username']}")
            return {'access_token': access_token}, 200
        
        logger.info(f"Failed login attempt for admin username: {admin_data['username']}")
        return {'message': 'Invalid credentials'}, 401

class AssignmentList(Resource):
    # @jwt_required()
    def get(self):
        admin_id = get_jwt_identity()
        try:
            assignments = AssignmentModel.find_by_admin(admin_id)
            logger.info(f"Assignments retrieved for admin: {admin_id}")
            assignment_list = [assignment.json() for assignment in assignments]
            logger.debug(f"Assignment list: {assignment_list}")
            return {'assignments': assignment_list}, 200
        except Exception as e:
            logger.error(f"Error in AssignmentList: {str(e)}")
            return {"message": "An error occurred retrieving the assignments.", "error": str(e)}, 500

class AcceptAssignment(Resource):
    @jwt_required()
    def post(self, id):
        admin_id = get_jwt_identity()
        logger.debug(f"Attempting to accept assignment: {id} by admin: {admin_id}")
        try:
            assignment = AssignmentModel.find_by_id(id)
            logger.debug(f"Assignment found: {assignment}")

            if not assignment:
                logger.warning(f"Attempt to accept non-existent assignment: {id}")
                return {'message': 'Assignment not found'}, 404

            if str(assignment.admin_id) != admin_id:
                logger.warning(f"Unauthorized attempt to accept assignment: {id} by admin: {admin_id}")
                return {'message': 'Not authorized to accept this assignment'}, 403

            assignment.status = 'accepted'
            assignment.save_to_db()
            logger.info(f"Assignment {id} accepted by admin {admin_id}")
            return {'message': 'Assignment accepted successfully.'}, 200
        except InvalidId:
            logger.warning(f"Invalid assignment id: {id}")
            return {"message": "Invalid assignment ID"}, 400
        except Exception as e:
            logger.error(f"Error in AcceptAssignment: {str(e)}")
            return {"message": "An error occurred accepting the assignment.", "error": str(e)}, 500

class RejectAssignment(Resource):
    @jwt_required()
    def post(self, id):
        admin_id = get_jwt_identity()
        logger.debug(f"Attempting to reject assignment: {id} by admin: {admin_id}")
        try:
            assignment = AssignmentModel.find_by_id(id)
            logger.debug(f"Assignment found: {assignment}")

            if not assignment:
                logger.warning(f"Attempt to reject non-existent assignment: {id}")
                return {'message': 'Assignment not found'}, 404

            if str(assignment.admin_id) != admin_id:
                logger.warning(f"Unauthorized attempt to reject assignment: {id} by admin: {admin_id}")
                return {'message': 'Not authorized to reject this assignment'}, 403

            assignment.status = 'rejected'
            assignment.save_to_db()
            logger.info(f"Assignment {id} rejected by admin {admin_id}")
            return {'message': 'Assignment rejected successfully.'}, 200
        except InvalidId:
            logger.warning(f"Invalid assignment id: {id}")
            return {"message": "Invalid assignment ID"}, 400
        except Exception as e:
            logger.error(f"Error in RejectAssignment: {str(e)}")
            return {"message": "An error occurred rejecting the assignment.", "error": str(e)}, 500
// File: resources/user.py
from flask_restful import Resource, reqparse
from flask import request
from flask_jwt_extended import create_access_token, jwt_required, get_jwt_identity
from models.user import UserModel
from models.admin import AdminModel
from models.assignment import AssignmentModel
from schemas import UserSchema, AssignmentSchema, AssignmentInputSchema
from marshmallow import ValidationError
import logging
from extensions import bcrypt
logger = logging.getLogger(__name__)
assignment_input_schema = AssignmentInputSchema()

logger = logging.getLogger(__name__)

user_schema = UserSchema()
assignment_schema = AssignmentSchema()

class UserRegister(Resource):
    def post(self):
        try:
            user_data = user_schema.load(request.get_json())
        except ValidationError as err:
            logger.error(f"Validation error in UserRegister: {err.messages}")
            return {"message": "Validation error", "errors": err.messages}, 400

        if UserModel.find_by_username(user_data['username']):
            logger.info(f"Attempted to register existing username: {user_data['username']}")
            return {"message": "A user with that username already exists"}, 400

        try:
            hashed_password = bcrypt.generate_password_hash(user_data['password']).decode('utf-8')
            user = UserModel(user_data['username'], hashed_password)
            user.save_to_db()
            logger.info(f"New user registered: {user_data['username']}")
            return {"message": "User created successfully."}, 201
        except Exception as e:
            logger.error(f"Error in UserRegister: {str(e)}")
            return {"message": "An error occurred creating the user."}, 500

class UserLogin(Resource):
    def post(self):
        try:
            user_data = user_schema.load(request.get_json())
        except ValidationError as err:
            logger.error(f"Validation error in UserLogin: {err.messages}")
            return {"message": "Validation error", "errors": err.messages}, 400

        user = UserModel.find_by_username(user_data['username'])

        if user and user.check_password(user_data['password']):
            access_token = create_access_token(identity=str(user._id))
            logger.info(f"User logged in: {user_data['username']}")
            return {'access_token': access_token}, 200
        
        logger.info(f"Failed login attempt for username: {user_data['username']}")
        return {'message': 'Invalid credentials'}, 401

class UploadAssignment(Resource):
    @jwt_required()
    def post(self):
        try:
            data = assignment_input_schema.load(request.get_json())
        except ValidationError as err:
            logger.error(f"Validation error in UploadAssignment: {err.messages}")
            return {"message": "Validation error", "errors": err.messages}, 400

        user_id = get_jwt_identity()
        admin = AdminModel.find_by_username(data['admin'])

        if not admin:
            logger.warning(f"Attempt to upload assignment to non-existent admin: {data['admin']}")
            return {'message': 'Admin not found'}, 404

        try:
            assignment = AssignmentModel(user_id, data['task'], str(admin._id))
            assignment.save_to_db()
            logger.info(f"New assignment uploaded by user {user_id} for admin {admin._id}")
            return {'message': 'Assignment uploaded successfully.', 'assignment_id': str(assignment._id)}, 201
        except Exception as e:
            logger.error(f"Error in UploadAssignment: {str(e)}")
            return {"message": "An error occurred uploading the assignment."}, 500

class AdminList(Resource):
    @jwt_required()
    def get(self):
        try:
            admins = [admin.username for admin in AdminModel.find_all()]
            logger.info("AdminList retrieved successfully")
            return {'admins': admins}, 200
        except Exception as e:
            logger.error(f"Error in AdminList: {str(e)}")
            return {"message": "An error occurred retrieving the admin list."}, 500
